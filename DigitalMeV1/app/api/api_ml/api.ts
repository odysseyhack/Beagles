/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * mobID-ML-API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2019-04-10T19:52:59Z
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from "./urlHelper";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://cem3gk697c.execute-api.eu-central-1.amazonaws.com/default".replace(
  /\/+$/,
  ""
);

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration!: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name!: "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 * This is sent from the phone when a user authorizes sharing some information with an entity.
 * @export
 * @interface AuthorizeInfoRequestInput
 */
export interface AuthorizeInfoRequestInput {
  /**
   * Id generated when the passport was registered or renewed. It identifies the user during a predefined amount of time (at the moment 5 days).
   * @type {string}
   * @memberof AuthorizeInfoRequestInput
   */
  mobIdToken: string;
  /**
   * Identifier of single operation for sharing data. It is retrieved from the QR code.
   * @type {string}
   * @memberof AuthorizeInfoRequestInput
   */
  requestId: string;
  /**
   * Identifier of the entity that requests the data (e.g. the airline). It is retrieved from the QR code.
   * @type {string}
   * @memberof AuthorizeInfoRequestInput
   */
  requesterId?: string;
  /**
   * Identifier of the place where access will be granted (e.g. the boarding gate). It is retrieved from the QR code.
   * @type {string}
   * @memberof AuthorizeInfoRequestInput
   */
  accessPointId?: string;
  /**
   *
   * @type {string}
   * @memberof AuthorizeInfoRequestInput
   */
  requestDate?: string;
  /**
   *
   * @type {string}
   * @memberof AuthorizeInfoRequestInput
   */
  requestType?: AuthorizeInfoRequestInput.RequestTypeEnum;
  /**
   *
   * @type {string}
   * @memberof AuthorizeInfoRequestInput
   */
  bookingId?: string;
  /**
   *
   * @type {boolean}
   * @memberof AuthorizeInfoRequestInput
   */
  declineAuthorization: boolean;
  /**
   * The data extracted from the phone and shared with the entity.
   * @type {Array<InfoAttribute>}
   * @memberof AuthorizeInfoRequestInput
   */
  attributes?: Array<InfoAttribute>;
}

/**
 * @export
 * @namespace AuthorizeInfoRequestInput
 */
export declare namespace AuthorizeInfoRequestInput {
  /**
   * @export
   * @enum {string}
   */
  export enum RequestTypeEnum {
    AirportEntry = "AirportEntry",
    BorderControl = "BorderControl",
    LoungeEntry = "LoungeEntry",
    Shopping = "Shopping",
    Parking = "Parking",
    Booking = "Booking"
  }
}

/**
 * Sent from the phone when the user demands all entities that have some data about him/her to delete such data.
 * @export
 * @interface ForgetMeInput
 */
export interface ForgetMeInput {
  /**
   *
   * @type {string}
   * @memberof ForgetMeInput
   */
  requestDate?: string;
  /**
   * List of ids generated every time the passport was registered or renewed. The phone stores all tokens, even after expiration, only to be able to request data linked to them to be forgotten.
   * @type {Array<string>}
   * @memberof ForgetMeInput
   */
  mobIdTokenList: Array<string>;
}

/**
 * Simple response that indicates if the action has been sucessful or not.
 * @export
 * @interface GenericProcessingOutput
 */
export interface GenericProcessingOutput {
  /**
   * true if the action has been sucessful.
   * @type {boolean}
   * @memberof GenericProcessingOutput
   */
  processingOK?: boolean;
  /**
   * An error message describing the reason for failure.
   * @type {string}
   * @memberof GenericProcessingOutput
   */
  errorMessage?: string;
}

/**
 * An attribute is some piece of personal data. It could be identification data, preferences, biometrics, etc.
 * @export
 * @interface InfoAttribute
 */
export interface InfoAttribute {
  /**
   * Identificative name of the attribute. An enumeration list is provided, but is not really an exhaustive list.
   * @type {string}
   * @memberof InfoAttribute
   */
  name?: InfoAttribute.NameEnum;
  /**
   * The data itself of the attribute. Binary data can be provided as an string encoded with Base64.
   * @type {string}
   * @memberof InfoAttribute
   */
  value?: string;
  /**
   * The hash of the value. Not used at the moment. It could be useful to sign the hash and then register in the blockchain, so later anyone could be able to prove the authenticity of the data just checking the hash.
   * @type {string}
   * @memberof InfoAttribute
   */
  hash?: string;
  /**
   * Signature of the value data provided by a trusted authority that has certified it. Useful in case that some data requires an strong certification, like the picture.
   * @type {string}
   * @memberof InfoAttribute
   */
  signature?: string;
  /**
   * true if the value has been encoded with Base64. For example, to provide a binary jpeg for the picture.
   * @type {boolean}
   * @memberof InfoAttribute
   */
  isEncodedBase64?: boolean;
}

/**
 * @export
 * @namespace InfoAttribute
 */
export declare namespace InfoAttribute {
  /**
   * @export
   * @enum {string}
   */
  export enum NameEnum {
    FirstName = "first_name",
    LastName = "last_name",
    BirthDate = "birth_date",
    Nationality = "nationality",
    PassportNumb = "passport_numb",
    PassportExpiryDate = "passport_expiry_date",
    FrequentFlyerNum = "frequent_flyer_num",
    FrequentFlyerProgram = "frequent_flyer_program",
    Picture = "picture",
    NationalIdNum = "national_id_num",
    NationalIdIssuingCountry = "national_id_issuing_country",
    NationalIdExpiryDate = "national_id_expiry_date",
    CreditCardNum = "credit_card_num",
    CreditCardExpiryDate = "credit_card_expiry_date"
  }
}

/**
 * After an entity has registered a request for information, the entity will keep polling to check if the user has approved sharing the information.
 * @export
 * @interface InfoRequestAuthorizedOutput
 */
export interface InfoRequestAuthorizedOutput {
  /**
   * false while no user has approved or rejected the request. The entity will keep asking until isCompleted becomes true.
   * @type {boolean}
   * @memberof InfoRequestAuthorizedOutput
   */
  isCompleted?: boolean;
  /**
   * true if the user accepted sharing the information.
   * @type {boolean}
   * @memberof InfoRequestAuthorizedOutput
   */
  isAuthorized?: boolean;
  /**
   * The values of the information requested by the entity when isAuthorized is true.
   * @type {Array<InfoAttribute>}
   * @memberof InfoRequestAuthorizedOutput
   */
  attributes?: Array<InfoAttribute>;
  /**
   *
   * @type {string}
   * @memberof InfoRequestAuthorizedOutput
   */
  errorMessage?: string;
}

/**
 * Sent to register an identity once a passport has been certified by a trusted authority. As a result a token id will be generated and provided to the phone. The token will be valid only during a predefined amount of time (at the moment 5 days).
 * @export
 * @interface PassportDetailsInput
 */
export interface PassportDetailsInput {
  /**
   *
   * @type {string}
   * @memberof PassportDetailsInput
   */
  issuingCountry?: string;
  /**
   *
   * @type {string}
   * @memberof PassportDetailsInput
   */
  gender?: PassportDetailsInputNs.GenderEnum;
  /**
   *
   * @type {number}
   * @memberof PassportDetailsInput
   */
  age?: number;
  /**
   *
   * @type {string}
   * @memberof PassportDetailsInput
   */
  requestDate?: string;
  /**
   *
   * @type {string}
   * @memberof PassportDetailsInput
   */
  passportStatus?: PassportDetailsInputNs.PassportStatusEnum;
  /**
   * List of attributes that require high degree of veracity, so they have been certified by an authotiry. For example, the name, birth date, passport number, passport expiry date, biometrics and other passport details.
   * @type {Array<InfoAttribute>}
   * @memberof PassportDetailsInput
   */
  attributes: Array<InfoAttribute>;
}

/**
 * @export
 * @namespace PassportDetailsInput
 */
export declare namespace PassportDetailsInputNs {
  /**
   * @export
   * @enum {string}
   */
  export enum GenderEnum {
    M = "M",
    F = "F"
  }
  /**
   * @export
   * @enum {string}
   */
  export enum PassportStatusEnum {
    Active = "Active",
    Expired = "Expired"
  }
}

/**
 *
 * @export
 * @interface PassportDetailsOutput
 */
export interface PassportDetailsOutput {
  /**
   * true if the registration has been sucessful.
   * @type {boolean}
   * @memberof PassportDetailsOutput
   */
  registrationOK?: boolean;
  /**
   * Token generated. It is a globally unique number that identifies the user and passport, but is valid only during a predefined amount of time (at the moment 5 days). After that a new token should be generated.
   * @type {string}
   * @memberof PassportDetailsOutput
   */
  mobIdToken?: string;
  /**
   * Date and Time in UTC zone when the token will be no longer valid.
   * @type {Date}
   * @memberof PassportDetailsOutput
   */
  validUntil?: Date;
  /**
   * An error message describing the reason for failure.
   * @type {string}
   * @memberof PassportDetailsOutput
   */
  errorMessage?: string;
}

/**
 * Sent from an entity (like an airline) to register a request to get personal data from the user or possibility of enter to some place. This is called before the QR code is generated.
 * @export
 * @interface RegisterInfoRequestInput
 */
export interface RegisterInfoRequestInput {
  /**
   * Id that identifies the entity.
   * @type {string}
   * @memberof RegisterInfoRequestInput
   */
  requesterId: string;
  /**
   * Id that identifies the place to enter. For example, a lounge, an airport gate, etc. It could be any name unique for the entity.
   * @type {string}
   * @memberof RegisterInfoRequestInput
   */
  accessPointId?: string;
  /**
   *
   * @type {string}
   * @memberof RegisterInfoRequestInput
   */
  requestDate?: string;
  /**
   *
   * @type {string}
   * @memberof RegisterInfoRequestInput
   */
  requestType?: RegisterInfoRequestInput.RequestTypeEnum;
  /**
   * List of attribute names that the entity wants to know from the user. For example, First Name, Last Name and Passport num. Only the property \"name\" should be provided for each attribute.
   * @type {Array<string>}
   * @memberof RegisterInfoRequestInput
   */
  requestedAttributes: Array<string>;
}

/**
 * @export
 * @namespace RegisterInfoRequestInput
 */
export declare namespace RegisterInfoRequestInput {
  /**
   * @export
   * @enum {string}
   */
  export enum RequestTypeEnum {
    AirportEntry = "AirportEntry",
    BorderControl = "BorderControl",
    LoungeEntry = "LoungeEntry",
    Shopping = "Shopping",
    Parking = "Parking",
    Booking = "Booking"
  }
}

/**
 *
 * @export
 * @interface RegisterInfoRequestOutput
 */
export interface RegisterInfoRequestOutput {
  /**
   * true if the registration has been sucessful.
   * @type {boolean}
   * @memberof RegisterInfoRequestOutput
   */
  registrationOK?: boolean;
  /**
   * Identifier automatically generated by the Middle Layer that identifies the request for sharing data that has been registered. It will be included in the QR code shown to the user and can be used to check the status of the authorization with the function \"isinforequestauthorized\".
   * @type {string}
   * @memberof RegisterInfoRequestOutput
   */
  requestId?: string;
  /**
   * An error message describing the reason for failure.
   * @type {string}
   * @memberof RegisterInfoRequestOutput
   */
  errorMessage?: string;
}

/**
 *
 * @export
 * @interface TransactionReportOutput
 */
export interface TransactionReportOutput {
  /**
   *
   * @type {Array<TransactionReportOutputTransactionsItem>}
   * @memberof TransactionReportOutput
   */
  transactions?: Array<TransactionReportOutputTransactionsItem>;
  /**
   *
   * @type {string}
   * @memberof TransactionReportOutput
   */
  errorMessage?: string;
}

/**
 *
 * @export
 * @interface TransactionReportOutputTransactionsItem
 */
export interface TransactionReportOutputTransactionsItem {
  /**
   *
   * @type {string}
   * @memberof TransactionReportOutputTransactionsItem
   */
  mobIdToken?: string;
  /**
   *
   * @type {string}
   * @memberof TransactionReportOutputTransactionsItem
   */
  requestDate?: string;
  /**
   *
   * @type {string}
   * @memberof TransactionReportOutputTransactionsItem
   */
  requestId?: string;
  /**
   *
   * @type {string}
   * @memberof TransactionReportOutputTransactionsItem
   */
  requestType?: string;
}

/**
 *
 * @export
 * @interface TravelDetailsInput
 */
export interface TravelDetailsInput {
  /**
   *
   * @type {string}
   * @memberof TravelDetailsInput
   */
  mobIdToken?: string;
  /**
   *
   * @type {string}
   * @memberof TravelDetailsInput
   */
  bookingId?: string;
  /**
   *
   * @type {string}
   * @memberof TravelDetailsInput
   */
  airlineId?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TravelDetailsInput
   */
  loungeAccess?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof TravelDetailsInput
   */
  shopNotifications?: boolean;
  /**
   *
   * @type {string}
   * @memberof TravelDetailsInput
   */
  travelType?: TravelDetailsInputNs.TravelTypeEnum;
  /**
   *
   * @type {string}
   * @memberof TravelDetailsInput
   */
  travelDate?: string;
}

/**
 * @export
 * @namespace TravelDetailsInput
 */
export declare namespace TravelDetailsInputNs {
  /**
   * @export
   * @enum {string}
   */
  export enum TravelTypeEnum {
    Domestic = "Domestic",
    International = "International",
    Schengen = "Schengen"
  }
}

/**
 *
 * @export
 * @interface WalletStatusOutput
 */
export interface WalletStatusOutput {
  /**
   * true if the token is valid.
   * @type {boolean}
   * @memberof WalletStatusOutput
   */
  valid?: boolean;
  /**
   * Date and Time in UTC zone when the token will be no longer valid.
   * @type {Date}
   * @memberof WalletStatusOutput
   */
  validUntil?: Date;
  /**
   * An error message describing the reason for failure.
   * @type {string}
   * @memberof WalletStatusOutput
   */
  errorMessage?: string;
}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {AuthorizeInfoRequestInput} authorizeInfoRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizeinforequestPost(
      authorizeInfoRequestInput: AuthorizeInfoRequestInput,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'authorizeInfoRequestInput' is not null or undefined
      if (
        authorizeInfoRequestInput === null ||
        authorizeInfoRequestInput === undefined
      ) {
        throw new RequiredError(
          "authorizeInfoRequestInput",
          "Required parameter authorizeInfoRequestInput was null or undefined when calling authorizeinforequestPost."
        );
      }
      const localVarPath = `/authorizeinforequest`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AuthorizeInfoRequestInput" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(authorizeInfoRequestInput || {})
        : authorizeInfoRequestInput || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {ForgetMeInput} forgetMeInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgetmePost(forgetMeInput: ForgetMeInput, options: any = {}): FetchArgs {
      // verify required parameter 'forgetMeInput' is not null or undefined
      if (forgetMeInput === null || forgetMeInput === undefined) {
        throw new RequiredError(
          "forgetMeInput",
          "Required parameter forgetMeInput was null or undefined when calling forgetmePost."
        );
      }
      const localVarPath = `/forgetme`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ForgetMeInput" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(forgetMeInput || {})
        : forgetMeInput || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} mobIdToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gettransactionreportGet(mobIdToken: string, options: any = {}): FetchArgs {
      // verify required parameter 'mobIdToken' is not null or undefined
      if (mobIdToken === null || mobIdToken === undefined) {
        throw new RequiredError(
          "mobIdToken",
          "Required parameter mobIdToken was null or undefined when calling gettransactionreportGet."
        );
      }
      const localVarPath = `/gettransactionreport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (mobIdToken !== undefined) {
        localVarQueryParameter["mobIdToken"] = mobIdToken;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} mobIdToken
     * @param {string} [requestDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getwalletstatusGet(
      mobIdToken: string,
      requestDate?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'mobIdToken' is not null or undefined
      if (mobIdToken === null || mobIdToken === undefined) {
        throw new RequiredError(
          "mobIdToken",
          "Required parameter mobIdToken was null or undefined when calling getwalletstatusGet."
        );
      }
      const localVarPath = `/getwalletstatus`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (requestDate !== undefined) {
        localVarQueryParameter["requestDate"] = requestDate;
      }

      if (mobIdToken !== undefined) {
        localVarQueryParameter["mobIdToken"] = mobIdToken;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isinforequestauthorizedGet(
      requestId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          "requestId",
          "Required parameter requestId was null or undefined when calling isinforequestauthorizedGet."
        );
      }
      const localVarPath = `/isinforequestauthorized`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (requestId !== undefined) {
        localVarQueryParameter["requestId"] = requestId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {RegisterInfoRequestInput} registerInfoRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerinforequestPost(
      registerInfoRequestInput: RegisterInfoRequestInput,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'registerInfoRequestInput' is not null or undefined
      if (
        registerInfoRequestInput === null ||
        registerInfoRequestInput === undefined
      ) {
        throw new RequiredError(
          "registerInfoRequestInput",
          "Required parameter registerInfoRequestInput was null or undefined when calling registerinforequestPost."
        );
      }
      const localVarPath = `/registerinforequest`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"RegisterInfoRequestInput" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(registerInfoRequestInput || {})
        : registerInfoRequestInput || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {PassportDetailsInput} passportDetailsInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerpassportdetailsPost(
      passportDetailsInput: PassportDetailsInput,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'passportDetailsInput' is not null or undefined
      if (passportDetailsInput === null || passportDetailsInput === undefined) {
        throw new RequiredError(
          "passportDetailsInput",
          "Required parameter passportDetailsInput was null or undefined when calling registerpassportdetailsPost."
        );
      }
      const localVarPath = `/registerpassportdetails`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"PassportDetailsInput" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(passportDetailsInput || {})
        : passportDetailsInput || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {TravelDetailsInput} travelDetailsInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registertraveldetailsPost(
      travelDetailsInput: TravelDetailsInput,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'travelDetailsInput' is not null or undefined
      if (travelDetailsInput === null || travelDetailsInput === undefined) {
        throw new RequiredError(
          "travelDetailsInput",
          "Required parameter travelDetailsInput was null or undefined when calling registertraveldetailsPost."
        );
      }
      const localVarPath = `/registertraveldetails`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"TravelDetailsInput" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(travelDetailsInput || {})
        : travelDetailsInput || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {AuthorizeInfoRequestInput} authorizeInfoRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizeinforequestPost(
      authorizeInfoRequestInput: AuthorizeInfoRequestInput,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<GenericProcessingOutput> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).authorizeinforequestPost(authorizeInfoRequestInput, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {ForgetMeInput} forgetMeInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgetmePost(
      forgetMeInput: ForgetMeInput,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<GenericProcessingOutput> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).forgetmePost(forgetMeInput, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} mobIdToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gettransactionreportGet(
      mobIdToken: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<TransactionReportOutput> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).gettransactionreportGet(mobIdToken, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} mobIdToken
     * @param {string} [requestDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getwalletstatusGet(
      mobIdToken: string,
      requestDate?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WalletStatusOutput> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).getwalletstatusGet(mobIdToken, requestDate, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isinforequestauthorizedGet(
      requestId: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<InfoRequestAuthorizedOutput> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).isinforequestauthorizedGet(requestId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {RegisterInfoRequestInput} registerInfoRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerinforequestPost(
      registerInfoRequestInput: RegisterInfoRequestInput,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<RegisterInfoRequestOutput> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).registerinforequestPost(registerInfoRequestInput, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {PassportDetailsInput} passportDetailsInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerpassportdetailsPost(
      passportDetailsInput: PassportDetailsInput,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PassportDetailsOutput> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).registerpassportdetailsPost(passportDetailsInput, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {TravelDetailsInput} travelDetailsInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registertraveldetailsPost(
      travelDetailsInput: TravelDetailsInput,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<GenericProcessingOutput> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).registertraveldetailsPost(travelDetailsInput, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {AuthorizeInfoRequestInput} authorizeInfoRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizeinforequestPost(
      authorizeInfoRequestInput: AuthorizeInfoRequestInput,
      options?: any
    ) {
      return DefaultApiFp(configuration).authorizeinforequestPost(
        authorizeInfoRequestInput,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {ForgetMeInput} forgetMeInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgetmePost(forgetMeInput: ForgetMeInput, options?: any) {
      return DefaultApiFp(configuration).forgetmePost(forgetMeInput, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {string} mobIdToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gettransactionreportGet(mobIdToken: string, options?: any) {
      return DefaultApiFp(configuration).gettransactionreportGet(
        mobIdToken,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {string} mobIdToken
     * @param {string} [requestDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getwalletstatusGet(
      mobIdToken: string,
      requestDate?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).getwalletstatusGet(
        mobIdToken,
        requestDate,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {string} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isinforequestauthorizedGet(requestId: string, options?: any) {
      return DefaultApiFp(configuration).isinforequestauthorizedGet(
        requestId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {RegisterInfoRequestInput} registerInfoRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerinforequestPost(
      registerInfoRequestInput: RegisterInfoRequestInput,
      options?: any
    ) {
      return DefaultApiFp(configuration).registerinforequestPost(
        registerInfoRequestInput,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {PassportDetailsInput} passportDetailsInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerpassportdetailsPost(
      passportDetailsInput: PassportDetailsInput,
      options?: any
    ) {
      return DefaultApiFp(configuration).registerpassportdetailsPost(
        passportDetailsInput,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {TravelDetailsInput} travelDetailsInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registertraveldetailsPost(
      travelDetailsInput: TravelDetailsInput,
      options?: any
    ) {
      return DefaultApiFp(configuration).registertraveldetailsPost(
        travelDetailsInput,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {AuthorizeInfoRequestInput} authorizeInfoRequestInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authorizeinforequestPost(
    authorizeInfoRequestInput: AuthorizeInfoRequestInput,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).authorizeinforequestPost(
      authorizeInfoRequestInput,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {ForgetMeInput} forgetMeInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public forgetmePost(forgetMeInput: ForgetMeInput, options?: any) {
    return DefaultApiFp(this.configuration).forgetmePost(
      forgetMeInput,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} mobIdToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public gettransactionreportGet(mobIdToken: string, options?: any) {
    return DefaultApiFp(this.configuration).gettransactionreportGet(
      mobIdToken,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} mobIdToken
   * @param {string} [requestDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getwalletstatusGet(
    mobIdToken: string,
    requestDate?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).getwalletstatusGet(
      mobIdToken,
      requestDate,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} requestId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public isinforequestauthorizedGet(requestId: string, options?: any) {
    return DefaultApiFp(this.configuration).isinforequestauthorizedGet(
      requestId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {RegisterInfoRequestInput} registerInfoRequestInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public registerinforequestPost(
    registerInfoRequestInput: RegisterInfoRequestInput,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).registerinforequestPost(
      registerInfoRequestInput,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {PassportDetailsInput} passportDetailsInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public registerpassportdetailsPost(
    passportDetailsInput: PassportDetailsInput,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).registerpassportdetailsPost(
      passportDetailsInput,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {TravelDetailsInput} travelDetailsInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public registertraveldetailsPost(
    travelDetailsInput: TravelDetailsInput,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).registertraveldetailsPost(
      travelDetailsInput,
      options
    )(this.fetch, this.basePath);
  }
}
